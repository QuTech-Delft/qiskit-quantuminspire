{
 "cells": [
  {
   "cell_type": "markdown",
   "source": [
    "# Superdense Coding\n",
    "This is a port of [this notebook](https://github.com/QuTech-Delft/quantum-inspire-examples/blob/dev/docs/notebooks_action_needed/superdense_coding/superdense_coding.ipynb).\n",
    "\n",
    "In this notebook, we use the Quantum Inspire to implement the superdense coding algorithm. With this quantum communication protocol, a sender (Bob) can transmit two classical bits of information to a receiver (Alice) using only one qubit. In addition, this method of communication is highly secure against eavesdropping since reading out the state during the communication will collapse the entangled state, indicating the presence of a third party listening.\n"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'qxelarator'",
     "output_type": "error",
     "traceback": [
      "\u001B[1;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[1;31mModuleNotFoundError\u001B[0m                       Traceback (most recent call last)",
      "Cell \u001B[1;32mIn[21], line 4\u001B[0m\n\u001B[0;32m      2\u001B[0m \u001B[38;5;28;01mfrom\u001B[39;00m \u001B[38;5;21;01mqiskit_quantuminspire\u001B[39;00m\u001B[38;5;21;01m.\u001B[39;00m\u001B[38;5;21;01mqi_provider\u001B[39;00m \u001B[38;5;28;01mimport\u001B[39;00m QIProvider\n\u001B[0;32m      3\u001B[0m \u001B[38;5;28;01mfrom\u001B[39;00m \u001B[38;5;21;01mqiskit_quantuminspire\u001B[39;00m\u001B[38;5;21;01m.\u001B[39;00m\u001B[38;5;21;01mcqasm\u001B[39;00m \u001B[38;5;28;01mimport\u001B[39;00m dumps\n\u001B[1;32m----> 4\u001B[0m \u001B[38;5;28;01mfrom\u001B[39;00m \u001B[38;5;21;01mqxelarator\u001B[39;00m \u001B[38;5;28;01mimport\u001B[39;00m execute_string\n\u001B[0;32m      5\u001B[0m \u001B[38;5;28;01mimport\u001B[39;00m \u001B[38;5;21;01mmatplotlib\u001B[39;00m\u001B[38;5;21;01m.\u001B[39;00m\u001B[38;5;21;01mpyplot\u001B[39;00m \u001B[38;5;28;01mas\u001B[39;00m \u001B[38;5;21;01mplt\u001B[39;00m\n",
      "\u001B[1;31mModuleNotFoundError\u001B[0m: No module named 'qxelarator'"
     ]
    }
   ],
   "source": [
    "from qiskit import QuantumCircuit\n",
    "from qiskit_quantuminspire.qi_provider import QIProvider\n",
    "from qiskit_quantuminspire.cqasm import dumps\n",
    "from qxelarator import execute_string\n",
    "import matplotlib.pyplot as plt"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2024-11-20T12:37:04.536147800Z",
     "start_time": "2024-11-20T12:37:04.456110900Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "### Generate the circuit\n",
    "\n",
    "The two qubits are initially prepared in the ground state 00. Before sending the qubit to Bob, Alice needs to prepare an entangled state. So, Alice applies a H-gate followed by a CNOT-gate to obtain the desired entangled state (1/sqrt(2)(00 + 11). Now the qubit is ready to be sent to Bob, who encodes the two classical bits of information.\n",
    "\n",
    "Bob can choose between four gates to apply to the qubit. Each gate will encode a different message for Alice. The four different possibilities are listed in the table below.\n",
    "\n",
    "| Gates\t | Classical Message |\n",
    "|:------:| :------: |\n",
    "|   I\t   | 00 |\n",
    "|   X\t   | 01 |\n",
    "|   Z\t   | 10 |\n",
    "|   ZX   | 11 |\n",
    "\n",
    "A different Bell state will be encoded for each gate that Bob applies to the qubit. After decoding, each Bell state will result in a different 2-bit message. Remember that the Identity gate doesn't alter the state, and the X and Z gates make the qubit do a pi-rotation over their respective axes.\n",
    "\n",
    "The different possible states after encoding will then be:\n",
    "\n",
    "After the encoding step, Bobs sends the qubit back to Alice. To decode the message, Alice applies a CNOT-gate followed by a H-gate, see Figure 1. The decoding of the '11' message is: H CNOT (1/sqrt(2)(-10 + 01) = 11\n",
    "\n",
    "The states after the different respective gate operations are listed in Table 1."
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "outputs": [],
   "source": [
    "def superdense_encoding_circuit(qubit_a: int =0, qubit_b: int =0) -> QuantumCircuit:\n",
    "    circuit = QuantumCircuit(2, 2)\n",
    "    circuit.reset(qubit_a)\n",
    "    circuit.reset(qubit_b)\n",
    "    circuit.measure(qubit_a, qubit_a)\n",
    "    circuit.measure(qubit_b, qubit_b)\n",
    "    circuit.ry(1.57079632679, qubit_a)\n",
    "    circuit.ry(-1.57079632679, qubit_b)\n",
    "    circuit.cz(qubit_b,qubit_a)\n",
    "\n",
    "    ## apply variable gate\n",
    "    encode_gate = 2**qubit_a + 2**qubit_b\n",
    "    if encode_gate == 0: # identity I\n",
    "        circuit.id(qubit_a)\n",
    "    elif encode_gate == 1: # X\n",
    "        circuit.x(qubit_a)\n",
    "    elif encode_gate == 2: # Z\n",
    "        circuit.z(qubit_a)\n",
    "    elif encode_gate == 3: # Y\n",
    "        circuit.y(qubit_a)\n",
    "\n",
    "    circuit.cz(qubit_b, qubit_a)\n",
    "    circuit.ry(-1.57079632679, qubit_a)\n",
    "    circuit.ry(1.57079632679, qubit_b)\n",
    "\n",
    "\n",
    "    circuit.measure(qubit_b, qubit_a)  # in qiskit this measures in z basis\n",
    "    circuit.measure(qubit_b, qubit_a)  # in qiskit this measures in z basis\n",
    "    circuit.measure(qubit_b, qubit_a)  # in qiskit this measures in z basis\n",
    "\n",
    "    return circuit\n"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "start_time": "2024-11-20T11:02:48.197216900Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "# Run the Circuit in Quantum Inspire\n",
    "We generate a circuit for each of the possibilities (00, 01, 10, 11) and then run the circuit in the Quantum Inspire. These are run in any of the backends of QI2. We then gather the results."
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "outputs": [],
   "source": [
    "fig, axs = plt.subplots(4, 1, figsize=(10, 16))\n",
    "\n",
    "result_map = {}\n",
    "for bit_a in range(2):\n",
    "    for bit_b in range(2):\n",
    "        circuit = superdense_encoding_circuit(bit_a, bit_b)\n",
    "        cqasm_string = dumps(circuit)\n",
    "        results = execute_string(cqasm_string, iterations=100).results\n",
    "        result_map[f'{bit_a}{bit_b}'] = results"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "start_time": "2024-11-20T11:02:48.198764800Z"
    }
   }
  },
  {
   "cell_type": "markdown",
   "source": [
    "# Plot results\n",
    "We plot the results of each encoding using matplot lib"
   ],
   "metadata": {
    "collapsed": false
   }
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'result_map' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001B[1;31m---------------------------------------------------------------------------\u001B[0m",
      "\u001B[1;31mNameError\u001B[0m                                 Traceback (most recent call last)",
      "Cell \u001B[1;32mIn[22], line 1\u001B[0m\n\u001B[1;32m----> 1\u001B[0m \u001B[38;5;28;01mfor\u001B[39;00m index, key \u001B[38;5;129;01min\u001B[39;00m \u001B[38;5;28menumerate\u001B[39m(\u001B[43mresult_map\u001B[49m):\n\u001B[0;32m      2\u001B[0m     results \u001B[38;5;241m=\u001B[39m result_map[key]\n\u001B[0;32m      3\u001B[0m     entries \u001B[38;5;241m=\u001B[39m \u001B[38;5;28mlist\u001B[39m(results\u001B[38;5;241m.\u001B[39mkeys())\n",
      "\u001B[1;31mNameError\u001B[0m: name 'result_map' is not defined"
     ]
    }
   ],
   "source": [
    "for index, key in enumerate(result_map):\n",
    "    results = result_map[key]\n",
    "    entries = list(results.keys())\n",
    "    occurrences = list(results.values())\n",
    "    axs[index].bar(entries, occurrences, color='skyblue')\n",
    "    axs[index].set_title(f'Supercoding {key}')\n",
    "    axs[index].set_xlabel('Entries')\n",
    "    axs[index].set_ylabel('Occurrences')\n",
    "\n",
    "# Adjust layout to prevent overlap\n",
    "plt.tight_layout()\n",
    "\n",
    "# Display the plot\n",
    "plt.show()\n"
   ],
   "metadata": {
    "collapsed": false,
    "ExecuteTime": {
     "end_time": "2024-11-20T12:50:57.519324200Z",
     "start_time": "2024-11-20T12:50:57.462245200Z"
    }
   }
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "outputs": [],
   "source": [],
   "metadata": {
    "collapsed": false
   }
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 0
}
